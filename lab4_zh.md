# lab4_zh
6.830 实验4：SimpleDB 事务

分配日期：2021年4月5日（星期一）<br>
截止日期：2021年4月22日（星期四）晚上11:59（美国东部时间）

在本实验中，您将在SimpleDB中实现一个基于锁的简单事务系统。您需要在代码的适当位置添加锁定和解锁调用，以及跟踪每个事务持有的锁并在需要时向事务授予锁的代码。

本文档的其余部分描述了添加事务支持涉及的内容，并提供了如何将此支持添加到数据库的基本概述。

与之前的实验一样，我们建议您尽早开始。锁定和事务调试可能相当棘手！

1. 开始

您应该从提交给实验3的代码开始（如果您没有提交实验3的代码，或者您的解决方案无法正常工作，请联系我们讨论选项）。此外，我们为本实验提供了额外的测试用例，这些测试用例不在您最初收到的原始代码分发中。我们再次强调，我们提供的单元测试是为了帮助指导您的实现，但它们并非旨在全面或确立正确性。

您需要将这些新文件添加到您的发布中。最简单的方法是切换到您的项目目录（可能称为simple-db-hw）并从主GitHub仓库拉取：

$ cd simple-db-hw
$ git pull upstream master


2. 事务、锁定和并发控制

在开始之前，您应该理解什么是事务以及严格的两阶段锁定（您将使用它来确保事务的隔离性和原子性）是如何工作的。

在本节的其余部分，我们简要概述这些概念，并讨论它们如何与SimpleDB相关。

2.1. 事务

事务是一组数据库操作（例如插入、删除和读取），这些操作被原子地执行；也就是说，要么所有操作都完成，要么都没有完成，并且对于数据库的外部观察者来说，这些操作不是作为单个不可分割的操作的一部分完成的。

2.2. ACID属性

为了帮助您理解事务管理在SimpleDB中如何工作，我们简要回顾它如何确保满足ACID属性：

• 原子性：严格的两阶段锁定和谨慎的缓冲管理确保原子性。

• 一致性：数据库通过原子性实现事务一致性。其他一致性问题（例如键约束）在SimpleDB中没有解决。

• 隔离性：严格的两阶段锁定提供隔离性。

• 持久性：FORCE缓冲管理策略确保持久性（见下面的第2.3节）。

2.3. 恢复和缓冲管理

为了简化您的工作，我们建议您实现NO STEAL/FORCE缓冲管理策略。

正如我们在课堂上讨论的，这意味着：

• 如果脏（已更新）页面被未提交的事务锁定，您不应该将其从缓冲池中驱逐（这是NO STEAL）。

• 在事务提交时，您应该强制脏页面写入磁盘（例如，将页面写出）（这是FORCE）。

为了进一步简化您的工作，您可以假设SimpleDB在处理transactionComplete命令时不会崩溃。请注意，这三点意味着您在本实验中不需要实现基于日志的恢复，因为您永远不需要撤销任何工作（您从不驱逐脏页面），也永远不需要重做任何工作（您在提交时强制更新，并且在提交处理期间不会崩溃）。

2.4. 授予锁

您需要在SimpleDB中添加调用（例如在BufferPool中），允许调用者代表特定事务请求或释放特定对象上的（共享或独占）锁。

我们建议在页面粒度上锁定；为了简化测试，请不要实现表级锁定（即使可能）。本文档的其余部分和我们的单元测试假设页面级锁定。

您需要创建跟踪每个事务持有哪些锁的数据结构，并在请求锁时检查是否应向事务授予锁。

您需要实现共享锁和独占锁；回想一下它们的工作原理如下：

• 事务在读取对象之前，必须拥有其上的共享锁。

• 事务在写入对象之前，必须拥有其上的独占锁。

• 多个事务可以在一个对象上拥有共享锁。

• 只有一个事务可以在一个对象上拥有独占锁。

• 如果事务t是唯一持有对象o上共享锁的事务，t可以将其在o上的锁升级为独占锁。

如果一个事务请求一个不能立即授予的锁，您的代码应该阻塞，等待该锁变为可用（即，被另一个在不同线程中运行的事务释放）。在您的锁实现中小心竞态条件——思考并发调用到您的锁如何影响行为。（您可能希望阅读Java中的http://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html）。

*

练习1。

在BufferPool中编写获取和释放锁的方法。假设您使用页面级锁定，您需要完成以下操作：

• 修改getPage()以阻塞并在返回页面之前获取所需的锁。

• 实现unsafeReleasePage()。此方法主要用于测试，以及事务结束时。

• 实现holdsLock()，以便练习2中的逻辑可以确定页面是否已被事务锁定。

您可能会发现定义一个负责维护事务和锁状态的LockManager类很有帮助，但设计决定取决于您。

在您的代码通过LockingTest中的单元测试之前，您可能需要先实现下一个练习。

*

2.5. 锁的生命周期

您需要实现严格的两阶段锁定。这意味着事务在访问任何对象之前应获取该对象上的适当类型的锁，并且在事务提交之前不应释放任何锁。

幸运的是，SimpleDB的设计使得在BufferPool.getPage()中获取页面上的锁是可能的，然后再读取或修改它们。因此，我们建议在getPage()中获取锁，而不是在每个操作符中添加锁定例程的调用。根据您的实现，您可能不需要在其他任何地方获取锁。这需要您自行验证！

您需要在读取任何页面（或元组）之前获取其上的共享锁，并在写入任何页面（或元组）之前获取其上的独占锁。您会注意到我们已经在BufferPool中传递Permissions对象；这些对象指示调用者希望对被访问对象具有的锁类型（我们已经为您提供了Permissions类的代码。）

请注意，您的HeapFile.insertTuple()和HeapFile.deleteTuple()的实现，以及HeapFile.iterator()返回的迭代器的实现，应使用BufferPool.getPage()访问页面。请仔细检查getPage()的这些不同用途是否传递了正确的权限对象（例如，Permissions.READ_WRITE或Permissions.READ_ONLY）。您可能还希望仔细检查您的BufferPool.insertTuple()和BufferPool.deleteTuple()的实现是否在它们访问的任何页面上调用markDirty()（您在实验2中实现此代码时应该已经完成了这一点，但我们没有测试这种情况。）

获取锁之后，您还需要考虑何时释放它们。显然，您应该在事务提交或中止后释放与事务关联的所有锁，以确保严格的两阶段锁定。但是，可能存在其他情况，在事务结束之前释放锁可能是有用的。例如，您可以在扫描页面以查找空槽后释放页面上的共享锁（如下所述）。

*

练习2。

确保在整个SimpleDB中获取和释放锁。您应该验证以下一些（但不一定是全部）操作是否正常工作：

• 在SeqScan期间从页面读取元组（如果您在BufferPool.getPage()中实现了锁定，只要您的HeapFile.iterator()使用BufferPool.getPage()，这应该正确工作。）

• 通过BufferPool和HeapFile方法插入和删除元组（如果您在BufferPool.getPage()中实现了锁定，只要HeapFile.insertTuple()和HeapFile.deleteTuple()使用BufferPool.getPage()，这应该正确工作。）

在以下情况下，您还需要特别努力地思考获取和释放锁：

• 向HeapFile添加新页面。您何时将页面物理写入磁盘？是否存在与其他事务（在其他线程上）的竞态条件，这些条件可能在HeapFile级别需要特别注意，而不考虑页面级锁定？

• 寻找可以插入元组的空槽。大多数实现会扫描页面寻找空槽，并且需要READ_ONLY锁来执行此操作。然而，令人惊讶的是，如果事务t在页面p上找不到空闲槽，t可以立即释放p上的锁。尽管这似乎违反了两阶段锁定的规则，但这是可以的，因为t没有使用页面中的任何数据，这样并发事务t'更新p不可能影响t的答案或结果。

此时，您的代码应该通过LockingTest中的单元测试。

*

2.6. 实现NO STEAL

来自事务的修改仅在提交后才写入磁盘。这意味着我们可以通过丢弃脏页面并从磁盘重新读取它们来中止事务。因此，我们绝不能驱逐脏页面。此策略称为NO STEAL。

您需要修改BufferPool中的evictPage方法。具体来说，它绝不能驱逐脏页面。如果您的驱逐策略偏好驱逐脏页面，您必须找到一种方法来驱逐替代页面。在缓冲池中所有页面都是脏的情况下，您应该抛出DbException。如果您的驱逐策略驱逐干净页面，请注意事务可能已经持有被驱逐页面上的任何锁，并在您的实现中适当处理它们。

*

练习3。

在BufferPool的evictPage方法中实现必要的逻辑，以便在不驱逐脏页面的情况下进行页面驱逐。

*

2.7. 事务

在SimpleDB中，TransactionId对象在每个查询开始时创建。此对象传递给查询中涉及的所有操作符。当查询完成时，调用BufferPool方法transactionComplete。

调用此方法提交或中止由参数标志commit指定的事务。在其执行期间的任何时刻，操作符可能抛出TransactionAbortedException异常，这表明发生了内部错误或死锁。我们提供的测试用例创建适当的TransactionId对象，以适当的方式将它们传递给您的操作符，并在查询完成时调用transactionComplete。我们也已经实现了TransactionId。

*

练习4.

实现BufferPool中的transactionComplete()方法。注意有两个版本的transactionComplete，一个接受额外的布尔commit参数，另一个不接受。没有额外参数的版本应始终提交，因此可以通过调用transactionComplete(tid, true)来实现。

当您提交时，应刷新与事务关联的脏页面到磁盘。当您中止时，应通过将页面恢复为其磁盘状态来恢复事务所做的任何更改。

无论事务提交还是中止，您还应释放BufferPool保存的关于该事务的任何状态，包括释放事务持有的任何锁。

此时，您的代码应该通过TransactionTest单元测试和AbortEvictionTest系统测试。您可能会发现TransactionTest系统测试有启发性，但在您完成下一个练习之前，它可能会失败。

2.8. 死锁和中止

SimpleDB中的事务可能死锁（如果您不理解原因，我们建议阅读Ramakrishnan & Gehrke中关于死锁的内容）。您需要检测这种情况并抛出TransactionAbortedException。

检测死锁有多种可能的方法。一个简单的示例是实现一个简单的超时策略，如果事务在给定时间段后未完成，则中止它。对于真正的解决方案，您可以实现讲座中所示的依赖图数据结构中的循环检测。在这种方案中，您将定期或在尝试授予新锁时检查依赖图中是否存在循环，如果存在循环则中止某些事务。检测到死锁后，您必须决定如何改善情况。假设您在事务t等待锁时检测到死锁。如果您有攻击性，您可能会中止t正在等待的所有事务；这可能导致大量工作被撤销，但您可以保证t将取得进展。或者，您可能决定中止t以给其他事务取得进展的机会。这意味着最终用户将不得不重试事务t。

另一种方法是使用事务的全局排序来避免构建等待图。这有时出于性能原因而更受青睐，但在此方案下，本可以成功的事务可能会被错误中止。示例包括WAIT-DIE和WOUND-WAIT方案。

*

练习5.

在src/simpledb/BufferPool.java中实现死锁检测或预防。对于您的死锁处理系统，您有许多设计决策，但不需要做高度复杂的事情。我们期望您做得比每个事务的简单超时更好。一个很好的起点是在每个锁请求之前在等待图中实现循环检测，对于这样的实现，您将获得满分。请在实验报告中描述您的选择，并与替代方案比较您选择的优缺点。

您应确保在发生死锁时正确中止事务，通过抛出TransactionAbortedException异常。此异常将被执行事务的代码（例如TransactionTest.java）捕获，该代码应调用transactionComplete()以在事务后进行清理。我们不期望自动重新启动因死锁而失败的事务——您可以假设更高级别的代码将处理此问题。

我们在test/simpledb/DeadlockTest.java中提供了一些（不太单元的）测试。它们实际上有点复杂，因此可能需要超过几秒钟的时间来运行（取决于您的策略）。如果它们似乎无限期挂起，那么您可能有一个未解决的死锁。这些测试构建了您的代码应该能够逃脱的简单死锁情况。

请注意，DeadLockTest.java顶部附近有两个时间参数；这些决定了测试检查锁是否已获取的频率以及中止事务重新启动前的等待时间。如果您使用基于超时的检测方法，通过调整这些参数，您可能会观察到不同的性能特征。测试将输出与已解决的死锁对应的TransactionAbortedExceptions到控制台。

您的代码现在应该通过TransactionTest系统测试（根据您的实现，这也可能运行相当长的时间）。

此时，您应该拥有一个可恢复的数据库，这意味着如果数据库系统崩溃（在transactionComplete()之外的某个点）或者用户显式中止事务，系统重新启动（或事务中止）后，任何运行中事务的影响将不可见。您可能希望通过运行一些事务并显式终止数据库服务器来验证这一点。

*

2.9. 设计替代方案

在本实验过程中，我们确定了一些您必须做出的重要设计选择：

• 锁定粒度：页面级与元组级

• 死锁处理：检测与预防，中止自己与他人

*

奖励练习6.（20%额外学分）

对于这些选择中的一个或多个，实现两种替代方案并通过实验比较它们的性能特征。在您的报告中包含您的基准测试代码和简要评估（可能带有图表）。

您现在已经完成了本实验。
干得好！

*

3. 后勤

您必须提交您的代码（见下文）以及一份简短（最多2页）的说明文档，描述您的方法。此文档应：

• 描述您在死锁处理中做出的任何设计决策，并列出您方法的优缺点。

• 讨论并证明您对API所做的任何更改。

• 描述代码中任何缺失或不完整的部分。

• 描述您在实验上花费的时间，以及是否有任何特别困难或令人困惑的地方。

• 描述您已完成的任何额外学分实现。

3.1. 合作

本实验单人应该可以完成，但如果您更愿意与合作伙伴一起工作，也可以。不允许更大的团队。请在您的文档中清楚说明您与谁（如果有的话）合作。

3.2. 提交您的作业

我们将使用gradescope自动评分所有编程作业。你们应该都被邀请加入课程实例；如果没有，请告诉我们，我们可以帮助您设置。您可以在截止日期前多次提交代码；我们将使用gradescope确定的最新版本。将文档放在名为lab4-writeup.txt的文件中，与您的提交一起。您还需要显式添加您创建的任何其他文件，例如新的*.java文件。

向gradescope提交的最简单方式是使用包含您代码的.zip文件。在Linux/MacOS上，您可以通过运行以下命令来实现：
$ zip -r submission.zip src/ lab4-writeup.txt


<a name="bugs"></a>
3.3. 提交错误

SimpleDB是一个相对复杂的代码库。很可能您会发现错误、不一致性以及糟糕、过时或不正确的文档等。

因此，我们要求您以冒险的心态来完成这个实验。如果某些内容不清楚甚至错误，请不要生气；而是尝试自己弄清楚或给我们发送一封友好的电子邮件。

请将（友好的！）错误报告提交至<a href="mailto:6.830-staff@mit.edu">6.830-staff@mit.edu</a>。提交时，请尝试包括：

• 错误描述。

• 一个<tt>.java</tt>文件，我们可以将其放入test/simpledb目录，编译并运行。

• 一个<tt>.txt</tt>文件，其中包含重现错误的数据。我们应该能够使用HeapFileEncoder将其转换为<tt>.dat</tt>文件。

如果您觉得自己遇到了错误，也可以在Piazza的班级页面上发布。

3.4 评分

<p>您成绩的50%将基于您的代码是否通过我们将运行的系统测试套件。这些测试将是我们提供的测试的超集。在提交代码之前，您应确保它从<tt>ant test</tt>和<tt>ant systemtest</tt>中都不产生错误（通过所有测试）。

新规定：

• 鉴于本实验将要求您大量修改早期代码，回归测试通过是评分测试的先决条件。这意味着如果您的提交未能通过早期实验的测试，您将获得0分自动评分分数，直到您修复它们。如果这对您是个问题，请联系我们讨论选项。

• 鉴于本实验涉及并发，我们将在截止日期后重新运行自动评分器，以防止尝试有错误的代码直到运气好。确保您的代码可靠地通过测试是您的责任。

• 与本实验之前的实验相比，手动评分的比例更高，达到50%。具体来说，如果您的并发处理是虚假的（例如，插入Thread.sleep(1000)直到竞态消失），我们将非常不满意。

重要： 在测试之前，gradescope将用我们的版本替换您的<tt>build.xml</tt>、<tt>HeapFileEncoder.java</tt>和<tt>test</tt>目录的全部内容。这意味着您不能更改<tt>.dat</tt>文件的格式！您还应小心更改我们的API。您应测试您的代码是否能够编译未修改的测试。

提交后，您应立即从gradescope获得反馈和失败测试的错误输出（如果有）。您成绩的另外50%将基于您的文档质量以及我们对您代码的主观评估。这部分也将在我们完成评分后发布在gradescope上。

我们设计这个作业时非常有趣，希望您也喜欢修改它！
